pipeline {
    agent any

    environment {
        // Jira configuration
        JIRA_PROJECT_KEY = 'DEVOPS'
        JIRA_SITE = 'ci-cd-project'
        
        // Docker configuration
        DOCKER_IMAGE = 'coperman12/ci-cd-exercise'
        DOCKER_CREDENTIALS_ID = 'dockerhub-credentials'
    }

    // stages {
    //     stage('Checkout') {
    //         steps {
    //             checkout scm
    //             script {
    //                 echo "Fetching code from GitHub repository"
    //                 sh 'git log -1 --pretty=format:"%h - %an, %ar : %s"'
    //             }
    //         }
    //     }

    //     stage('Test') {
    //         steps {
    //             script {
    //                 echo "Running Tests..."
    //                 // Install dependencies and run tests
    //                 // Using pip inside the agent (assuming agent has python or we use a docker agent for this stage if needed)
    //                 // If 'agent any' is local mac, valid python should be available or we can run in docker
    //                  try {
    //                     sh 'pip install -r requirements.txt'
    //                     sh 'pytest --junitxml=reports/result.xml'
    //                 } catch (Exception e) {
    //                     currentBuild.result = 'FAILURE'
    //                     throw e
    //                 }
    //             }
    //         }
    //     }

    //     stage('Build & Push Docker') {
    //         when {
    //             expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
    //         }
    //         steps {
    //             script {
    //                 echo "Building Docker Image..."
    //                 docker.withRegistry('', "$DOCKER_CREDENTIALS_ID") {
    //                     // Build using the Dockerfile in 'docker/' directory, context is root '.'
    //                     def app = docker.build("$DOCKER_IMAGE:${env.BUILD_NUMBER}", "-f docker/Dockerfile .")
                        
    //                     echo "Pushing Docker Image..."
    //                     app.push()
    //                     app.push("latest")
    //                 }
    //             }
    //         }
    //     }
    // }
stages {
        stage('Setup Environment') {
            steps {
                script {
                    sh '''
                    
                        echo "Setting up Python environment"
                        
                        # Install System Dependencies
                        apt-get update && apt-get install -y python3 python3-venv python3-pip wget gnupg unzip curl xvfb libxi6 libgbm1 libnss3 docker.io
                        
                        # Install Chrome
                        mkdir -p /etc/apt/keyrings
                        wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | gpg --dearmor --batch --yes -o /etc/apt/keyrings/google-chrome.gpg
                        echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/google-chrome.gpg] http://dl.google.com/linux/chrome/deb/ stable main" > /etc/apt/sources.list.d/google-chrome.list
                        apt-get update && apt-get install -y google-chrome-stable

                        # Setup Python Virtual Env
                        python${PYTHON_VERSION} -m venv ${VENV_DIR}
                        
                        # Activate and Install Requirements
                        # (Note: We use the direct path to avoid 'source' issues)
                        ${VENV_DIR}/bin/pip install --upgrade pip
                        ${VENV_DIR}/bin/pip install -r requirements.txt
                        
                        echo "Starting application..."
                        # Run in background AND save the PID to a file named 'app.pid'
                        nohup ${VENV_DIR}/bin/python main.py > app.log 2>&1 & echo $! > app.pid
                    '''
                }
            }
        }
        
        
        stage('Lint Code') {
            steps {
                script {
                    sh '. ${VENV_DIR}/bin/activate && flake8 app/ --output-file=reports/flake8.txt || true'
                    sh '. ${VENV_DIR}/bin/activate && pylint app/ --output=reports/pylint.txt || true'
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'reports/*.txt', allowEmptyArchive: true
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                script {
                    sh 'mkdir -p reports'
                    sh '. ${VENV_DIR}/bin/activate && pytest tests/unit/ -v --cov=app --cov-report=xml --cov-report=html --junit-xml=reports/unit-tests.xml'
                }
            }
            post {
                always {
                    junit 'reports/unit-tests.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Unit Test Coverage Report'
                    ])
                    archiveArtifacts artifacts: 'htmlcov/**/*', allowEmptyArchive: false
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                script {
                    sh '. ${VENV_DIR}/bin/activate && pytest tests/integration/ -v --junit-xml=reports/integration-tests.xml'
                }
            }
            post {
                always {
                    junit 'reports/integration-tests.xml'
                }
            }
        }
        
        stage('End-to-End Tests') {
            steps {
                script {
                    sh '''
                        . ${VENV_DIR}/bin/activate
                        export DISPLAY=:99
                        Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
                        sleep 3
                        pytest tests/e2e/ -v --junit-xml=reports/e2e-tests.xml
                        killall Xvfb || true
                    '''
                }
            }
            post {
                always {
                    junit 'reports/e2e-tests.xml'
                }
            }
        }
        
        stage('Build & Push Docker Image') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    withCredentials([
                        usernamePassword(credentialsId: 'docker-hub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS'),
                        usernamePassword(credentialsId: 'github-token', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_TOKEN')
                    ]) {
                        sh """
                            git config --global user.email "jenkins@ci-cd-pipeline.local"
                            git config --global user.name "Jenkins CI Bot"
                            # Important: Set the remote URL to use the token for authentication
                            git remote set-url origin https://${GIT_USER}:${GIT_TOKEN}@github.com/coperman/Devops-ci-cd-exercise.git
                            git fetch --tags
                        """

                        def latestTag = sh(
                            script: "git tag --sort=-v:refname | grep -E '^v?[0-9.]+\$' | head -n1",
                            returnStdout: true
                        ).trim()

                        if (latestTag == "") {
                            latestTag = "v0.0.0"
                        }
                        
                        echo "Latest Git Tag: ${latestTag}"

                        def cleanTag = latestTag.replace('v', '')
                        def parts = cleanTag.tokenize('.')
                        def newVersion = "v${parts[0]}.${parts[1]}.${parts[2].toInteger() + 1}"
                        
                        echo "---------------------------------------"
                        echo "   New Release Version: ${newVersion}"
                        echo "---------------------------------------"

                        sh """
                            echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin
                            
                            echo "Building ${newVersion}..."
                            docker build -f docker/Dockerfile -t coperman/devops-testing-app:${newVersion} .
                            docker tag coperman/devops-testing-app:${newVersion} coperman/devops-testing-app:latest
                            
                            echo "Pushing Docker images..."
                            docker push coperman/devops-testing-app:${newVersion}
                            docker push coperman/devops-testing-app:latest
                            
                            docker logout
                        """

                        sh """
                            echo "Pushing new tag to GitHub..."
                            git tag -a ${newVersion} -m "Jenkins Build ${BUILD_NUMBER}"
                            git push origin ${newVersion}
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                script {
                    sh '''
                        echo "Deploying to staging environment"
                        docker stop staging-app || true
                        docker rm staging-app || true
                        docker run -d --name staging-app -p 5001:5000 devops-testing-app:${BUILD_NUMBER}
                        
                        sleep 5
                        curl -f http://localhost:5001/health || exit 1
                    '''
                }
            }
        }
    }
    post {
        always {
            script {
                // Send Email Notification
                echo "Sending Email..."
                // Note: Configure Email Extension Plugin in Jenkins Global Configuration first
                emailext body: "Build ${currentBuild.currentResult}: ${env.BUILD_URL}",
                         subject: "Job ${env.JOB_NAME} - Build # ${env.BUILD_NUMBER} - ${currentBuild.currentResult}",
                         to: "user@example.com" // Replace with actual recipient if not dynamic
            }
        }
        success {
            script {
                sh 'echo "Pipeline completed successfully!"'
                def userEmail = "coperman12@gmail.com" 
                emailext (
                    subject: "âœ… Pipeline Success: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                    body: """<p>The pipeline completed successfully!</p><p><a href="${env.BUILD_URL}">View Build Details</a></p>""",
                    to: userEmail
                )
                cleanWs()
            }
        }
        failure {
            script {
                echo "Creating Issue on JIRA..."
                jiraNewIssue site: env.JIRA_SITE, issue: [
                    fields: [
                        project: [key: env.JIRA_PROJECT_KEY],
                        summary: "Build Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}",
                        description: "Build Failed. URL: ${env.BUILD_URL}\nBranch: ${env.BRANCH_NAME}",
                        issuetype: [name: 'Bug']
                    ]
                ]
            }
        }
    }
}
